
# REDIS
> string hash list set zset

## Redis 持久化机制
```markdown
RDB是Redis默认的持久化方式。
按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。
即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。

AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。
当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。
```



--------------------------------------------------------------------------------

## 缓存雪崩
由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，
而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。

从而形成一系列连锁反应，造成整个系统崩溃。
(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)


**解决办法**

1、加锁或者队列保证不会有有大量的线程对数据库一次性进行读写，
从而避免失效时大量的并发请求落到底层存储系统上

2、将缓存失效时间分散开

--------------------------------------------------------------------------------

## 缓存穿透
缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。
这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。
这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。

***解决方法***

1、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，
一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

2、如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存， 但它的过期时间会很短，最长不超过五分钟。

通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。

--------------------------------------------------------------------------------
## 缓存击穿
指一个key非常热点，大并发集中对这个key进行访问，
当这个key在失效的瞬间，仍然持续的大并发访问就穿破缓存，转而直接请求数据库。

**解决方案**
在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，
访问结束再删除该短期key。

--------------------------------------------------------------------------------
## 缓存预热
缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。
这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！
用户直接查询事先被预热的缓存数据！

解决思路：

1、直接写个缓存刷新页面，上线时手工操作下；

2、数据量不大，可以在项目启动的时候自动进行加载；

3、定时刷新缓存；

--------------------------------------------------------------------------------
## 缓存更新
（1）定时去清理过期的缓存；

（2）当有用户请求过来时，判断这个请求所用到的缓存是否过期，
过期的话就去底层系统得到新数据并更新缓存。

（3）Redis默认的策略

--------------------------------------------------------------------------------
## 缓存降级
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，
仍然需要保证服务还是可用的，即使是有损服务。
系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
降级的最终目的是保证核心服务可用，即使是有损的。
而且有些服务是无法降级的（如加入购物车、结算）

--------------------------------------------------------------------------------
## 热数据与冷数据
热点数据，缓存才有价值
对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。
频繁修改的数据，看情况考虑使用缓存

--------------------------------------------------------------------------------
## Memcache与Redis的区别都有哪些？
1) 存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
   Redis有部份存在硬盘上，redis可以持久化其数据
2) 数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，
   支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储
3) 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
   Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4) value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。
   5）redis的速度比memcached快很多
   6）Redis支持数据的备份，即master-slave模式的数据备份。

--------------------------------------------------------------------------------
## 单线程的redis
(一)纯内存操作

(二)单线程操作，避免了频繁的上下文切换

(三)采用了非阻塞I/O多路复用机制

--------------------------------------------------------------------------------
## redis的过期策略以及内存淘汰机制
redis采用的是定期删除+惰性删除策略。
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。
需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。
因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。
采用定期删除+惰性删除就没其他问题了么?
不是的，如果定期删除没删除key。
然后你也没即时去请求key，也就是说惰性删除也没生效。、这样，redis的内存会越来越高。
那么就应该采用内存淘汰机制。

## 内存淘汰机制
**maxmemory-policy volatile-lru**

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错

***
如果没有设置 expire 的key, 不满足先决条件(prerequisites);
那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。
***

--------------------------------------------------------------------------------
## Redis 常见性能问题和解决方案？

(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件

(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次

(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内

(4) 尽量避免在压力很大的主库上增加从库

(5) 主从复制不要用图状结构，用单向链表结构更为稳定

## Redis实现分布式锁
Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。
将 key 的值设为value，当且仅当key不存在。
若给定的 key 已经存在，则 SETNX 不做任何动作

解锁：使用 del key 命令就能释放锁

解决死锁：

1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。

2） 使用 setnx key “当前系统时间+锁持有的时间”
和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。


## PHP实现Redis原子锁
```phpt
<?php 
$redis = new Redis();
$redis->connect('localhost', 6379);


$lock_name = 'my_lock';
$acquired = $redis->setnx($lock_name, '1');


if ($acquired) {
  
    $redis->del($lock_name);
} else {
  
}
?>

```