## mysql常见知识点

### 1. 常见的关系型数据库管理系统？

答：Oracle、SQL Server、MySQL、Sybase、DB2、Access等。

### 2.什么是事务？及其特性？

答：事务：是一系列的[数据库操作](http://www.php.cn/php/php-Database-operations.html)，是数据库应用的基本逻辑单位。

事务特性：

（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态

（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

或者这样理解：

事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性

### 3.char和varchar的区别？

答：是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：

char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．

### 4.myisam和innodb的区别

MyISAM 是非事务的存储引擎；适合用于频繁查询的应用；表锁，不会出现死锁；适合小数据，小并发

innodb是支持事务的存储引擎；合于插入和更新操作比较多的应用；设计合理的话是行锁（最大区别就在锁的级别上）；适合大数据，大并发。

### 5.数据表类型有哪些

答：MyISAM、InnoDB、HEAP、BOB,ARCHIVE,CSV等。

MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。

InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。

### 6.mysql 隔离级别

读未提交【READ UNCOMMITTED】
这是最低的隔离级别。 在此级别，事务可以看到其他事务尚未提交的数据。 这可能会导致脏读，其中一个事务看到的数据已被更改但尚未被另一个事务提交。

读已提交【READ COMMITTED】
这是 MySQL 中的默认隔离级别。 在这一层，事务只能看到其他事务已经提交的数据。 这可以防止脏读，但也可能导致更新丢失，即一个事务在第一个事务开始之后但在提交之前看到的数据已被另一个事务更改。

可重复读【REPEATABLE READ】
此隔离级别保证事务在事务期间将看到相同的数据，即使其他事务更改了该数据。 这可以防止脏读和丢失更新，但也可能导致幻读，即事务在执行两次时看到同一查询的不同数据。

可序列化【SERIALIZABLE】
这是最高的隔离级别。 在此级别中，事务彼此隔离，就好像它们是串行运行的一样。 这可以防止脏读、丢失更新和幻读，但也可能导致死锁和性能问题。

使用的最佳隔离级别取决于特定的应用程序。 

如果应用程序对脏读不敏感，那么可以使用 READ UNCOMMITTED 以获得更好的性能。 

如果应用程序对脏读敏感，则应使用 READ COMMITTED。 

如果应用程序也对丢失更新敏感，则应使用 REPEATABLE READ。

如果应用程序对所有三种类型的异常都敏感，则应使用 SERIALIZABLE。

----------------------------------------------------------------------------
## mysql优化

#### 第一范式

每个字段都是原子项，不可以在分割

#### 第二范式

满足第一范式，并且所有属性（字段）都依赖于主键

#### 第三范式

满足第二范式，消除传递依赖

### 数据库设计规则

*   一般选择MyISAM，需要事务的时候选择innodb，前者效率相当高，以主键查询时后者高
*   数据库和表名要尽量和业务模块保持一致
*   灵活使用char和varchar，超大文本如日志追加到文件中
*   timestamp（4字节）代替datetime（8字节），整型代替浮点型
*   适当时候可以不完全遵守三范式

### 数据库优化原则

*   设计时候严格遵守三范式，适当时候反范式设计
*   开启慢查询，分析哪个sql语句较慢，记录日志进行分析
*   用explain/desc进行分析
*   在应用层面上优化用memcache和redis进行缓存，生成静态页面，将压力向前端分担
*   千万条数据，尽量不使用存储过程、触发器等复杂的业务逻辑，将一些运算交给php
*   从架构上进行调整，读写分离，避免在单台机器消耗过多资源
*   分库分表分机器 分区
*   上亿级（700G左右）使用数据库中间件
*   尽量在sql语句中不使用or、like
*   如果非要使用全文索引，可以使用全文索引服务器xunsearch
*   可以加固态硬盘、内存条
*   为了方便查询，添加索引

### mysql语句优化

*   查询优化，避免全表扫描，在where、order经常涉及的列加索引

*   避免进行is null判断，会造成全表扫描

*   尽量不要在where中使用!=     >      <       or，容易造成全表扫描

*   in、not in 也会造成全表扫描

*   尽量不要进行字段的操作

    ```mysql
    select id from t1 where  num/2=100;
    改为 
    select id from t1 where  num=100*2;
    ```

*   尽量不要砸语句中使用函数

    ```mysql
    select id from t1 where datediff(now(),'2017-01-01 18:12:13');
    改为 
    select id from t1 where createdate>='' and createdate < '';
    ```

*   不要写没有意义的查询

*   如果索引列有大量重复的数据，引擎会放弃使用索引

*   尽量避免向客户端返回超大的数据量，如果需要返回，要考虑需求是否合理

### 防止sql注入

*   PDO预处理，用?绑定变量
*   前段js对特殊字符进行转义
*   TP5 自带方法Request::instance()
*   nginx反向代理完成url过滤，可以阻挡90%的攻击
*   权限问题，不要让用户拥有root权限
*   错误提示关闭，不要让用户看到报错信息
*   用户信息严格加密

#### 慢查询

```shell
vi /etc/my.cnf
```

```shell
[mysql]
long_query_time = 2					#记录查询慢于2s的语句
log-slow-queries = log-slow.log
log-queries-not-using-indexes		#记录所有没有使用索引的语句
```

自带分析器分析慢查询日志

    /usr/local/mysql/bin/mysqldumpslow /usr/local/mysql/var/log-slow.log

